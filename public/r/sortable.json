{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "sortable",
  "type": "registry:component",
  "title": "Sortable",
  "description": "A sortable component",
  "dependencies": [
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities"
  ],
  "registryDependencies": [
    "utils",
    "button"
  ],
  "files": [
    {
      "path": "registry/default/components/sortable.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport type {\n  DndContextProps,\n  DraggableSyntheticListeners,\n  DropAnimation,\n  UniqueIdentifier,\n} from \"@dnd-kit/core\";\nimport {\n  closestCenter,\n  defaultDropAnimationSideEffects,\n  DndContext,\n  DragOverlay,\n  KeyboardSensor,\n  MouseSensor,\n  TouchSensor,\n  useSensor,\n  useSensors,\n} from \"@dnd-kit/core\";\nimport {\n  restrictToHorizontalAxis,\n  restrictToParentElement,\n  restrictToVerticalAxis,\n} from \"@dnd-kit/modifiers\";\nimport {\n  arrayMove,\n  horizontalListSortingStrategy,\n  SortableContext,\n  useSortable,\n  verticalListSortingStrategy,\n  type SortableContextProps,\n} from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { Slot, type SlotProps } from \"@radix-ui/react-slot\";\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.RefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]) {\n  return (node: T) => refs.forEach((ref) => setRef(ref, node));\n}\n\nconst orientationConfig = {\n  vertical: {\n    modifiers: [restrictToVerticalAxis, restrictToParentElement],\n    strategy: verticalListSortingStrategy,\n  },\n  horizontal: {\n    modifiers: [restrictToHorizontalAxis, restrictToParentElement],\n    strategy: horizontalListSortingStrategy,\n  },\n  mixed: {\n    modifiers: [restrictToParentElement],\n    strategy: undefined,\n  },\n};\n\ninterface SortableProps<TData extends { id: UniqueIdentifier }>\n  extends DndContextProps {\n  /**\n   * An array of data items that the sortable component will render.\n   * @example\n   * value={[\n   *   { id: 1, name: 'Item 1' },\n   *   { id: 2, name: 'Item 2' },\n   * ]}\n   */\n  value: TData[];\n\n  /**\n   * An optional callback function that is called when the order of the data items changes.\n   * It receives the new array of items as its argument.\n   * @example\n   * onValueChange={(items) => console.log(items)}\n   */\n  onValueChange?: (items: TData[]) => void;\n\n  /**\n   * An optional callback function that is called when an item is moved.\n   * It receives an event object with `activeIndex` and `overIndex` properties, representing the original and new positions of the moved item.\n   * This will override the default behavior of updating the order of the data items.\n   * @type (event: { activeIndex: number; overIndex: number }) => void\n   * @example\n   * onMove={(event) => console.log(`Item moved from index ${event.activeIndex} to index ${event.overIndex}`)}\n   */\n  onMove?: (event: { activeIndex: number; overIndex: number }) => void;\n\n  /**\n   * A collision detection strategy that will be used to determine the closest sortable item.\n   * @default closestCenter\n   * @type DndContextProps[\"collisionDetection\"]\n   */\n  collisionDetection?: DndContextProps[\"collisionDetection\"];\n\n  /**\n   * An array of modifiers that will be used to modify the behavior of the sortable component.\n   * @default\n   * [restrictToVerticalAxis, restrictToParentElement]\n   * @type Modifier[]\n   */\n  modifiers?: DndContextProps[\"modifiers\"];\n\n  /**\n   * A sorting strategy that will be used to determine the new order of the data items.\n   * @default verticalListSortingStrategy\n   * @type SortableContextProps[\"strategy\"]\n   */\n  strategy?: SortableContextProps[\"strategy\"];\n\n  /**\n   * Specifies the axis for the drag-and-drop operation. It can be \"vertical\", \"horizontal\", or \"both\".\n   * @default \"vertical\"\n   * @type \"vertical\" | \"horizontal\" | \"mixed\"\n   */\n  orientation?: \"vertical\" | \"horizontal\" | \"mixed\";\n\n  /**\n   * An optional React node that is rendered on top of the sortable component.\n   * It can be used to display additional information or controls.\n   * @default null\n   * @type React.ReactNode | null\n   * @example\n   * overlay={<Skeleton className=\"w-full h-8\" />}\n   */\n  overlay?: React.ReactNode | null;\n}\n\nfunction Sortable<TData extends { id: UniqueIdentifier }>({\n  value,\n  onValueChange,\n  collisionDetection = closestCenter,\n  modifiers,\n  strategy,\n  onMove,\n  orientation = \"vertical\",\n  overlay,\n  children,\n  ...props\n}: SortableProps<TData>) {\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\n  const sensors = useSensors(\n    useSensor(MouseSensor),\n    useSensor(TouchSensor),\n    useSensor(KeyboardSensor),\n  );\n\n  const config = orientationConfig[orientation];\n\n  return (\n    <DndContext\n      modifiers={modifiers ?? config.modifiers}\n      sensors={sensors}\n      onDragStart={({ active }) => setActiveId(active.id)}\n      onDragEnd={({ active, over }) => {\n        if (over && active.id !== over?.id) {\n          const activeIndex = value.findIndex((item) => item.id === active.id);\n          const overIndex = value.findIndex((item) => item.id === over.id);\n\n          if (onMove) {\n            onMove({ activeIndex, overIndex });\n          } else {\n            onValueChange?.(arrayMove(value, activeIndex, overIndex));\n          }\n        }\n        setActiveId(null);\n      }}\n      onDragCancel={() => setActiveId(null)}\n      collisionDetection={collisionDetection}\n      {...props}\n    >\n      <SortableContext items={value} strategy={strategy ?? config.strategy}>\n        {children}\n      </SortableContext>\n      {overlay ? (\n        <SortableOverlay activeId={activeId}>{overlay}</SortableOverlay>\n      ) : null}\n    </DndContext>\n  );\n}\n\nconst dropAnimationOpts: DropAnimation = {\n  sideEffects: defaultDropAnimationSideEffects({\n    styles: {\n      active: {\n        opacity: \"0.4\",\n      },\n    },\n  }),\n};\n\ninterface SortableOverlayProps\n  extends React.ComponentPropsWithRef<typeof DragOverlay> {\n  activeId?: UniqueIdentifier | null;\n}\n\nconst SortableOverlay = React.forwardRef<HTMLDivElement, SortableOverlayProps>(\n  (\n    { activeId, dropAnimation = dropAnimationOpts, children, ...props },\n    ref,\n  ) => {\n    return (\n      <DragOverlay dropAnimation={dropAnimation} {...props}>\n        {activeId ? (\n          <SortableItem\n            ref={ref}\n            value={activeId}\n            className=\"cursor-grabbing\"\n            asChild\n          >\n            {children}\n          </SortableItem>\n        ) : null}\n      </DragOverlay>\n    );\n  },\n);\n\nSortableOverlay.displayName = \"SortableOverlay\";\n\ninterface SortableItemContextProps {\n  attributes: React.HTMLAttributes<HTMLElement>;\n  listeners: DraggableSyntheticListeners | undefined;\n  isDragging?: boolean;\n}\n\nconst SortableItemContext = React.createContext<SortableItemContextProps>({\n  attributes: {},\n  listeners: undefined,\n  isDragging: false,\n});\n\nfunction useSortableItem() {\n  const context = React.useContext(SortableItemContext);\n\n  if (!context) {\n    throw new Error(\"useSortableItem must be used within a SortableItem\");\n  }\n\n  return context;\n}\n\ninterface SortableItemProps extends SlotProps {\n  /**\n   * The unique identifier of the item.\n   * @example \"item-1\"\n   * @type UniqueIdentifier\n   */\n  value: UniqueIdentifier;\n\n  /**\n   * Specifies whether the item should act as a trigger for the drag-and-drop action.\n   * @default false\n   * @type boolean | undefined\n   */\n  asTrigger?: boolean;\n\n  /**\n   * Merges the item's props into its immediate child.\n   * @default false\n   * @type boolean | undefined\n   */\n  asChild?: boolean;\n}\n\nconst SortableItem = React.forwardRef<HTMLDivElement, SortableItemProps>(\n  ({ value, asTrigger, asChild, className, ...props }, ref) => {\n    const {\n      attributes,\n      listeners,\n      setNodeRef,\n      transform,\n      transition,\n      isDragging,\n    } = useSortable({ id: value });\n\n    const context = React.useMemo<SortableItemContextProps>(\n      () => ({\n        attributes,\n        listeners,\n        isDragging,\n      }),\n      [attributes, listeners, isDragging],\n    );\n\n    const style: React.CSSProperties = {\n      opacity: isDragging ? 0.5 : 1,\n      transform: CSS.Translate.toString(transform),\n      transition,\n    };\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <SortableItemContext.Provider value={context}>\n        <Comp\n          data-state={isDragging ? \"dragging\" : undefined}\n          className={cn(\n            \"data-[state=dragging]:cursor-grabbing\",\n            { \"cursor-grab\": !isDragging && asTrigger },\n            className,\n          )}\n          ref={composeRefs(ref, setNodeRef as React.Ref<HTMLDivElement>)}\n          style={style}\n          {...(asTrigger ? attributes : {})}\n          {...(asTrigger ? listeners : {})}\n          {...props}\n        />\n      </SortableItemContext.Provider>\n    );\n  },\n);\nSortableItem.displayName = \"SortableItem\";\n\ninterface SortableDragHandleProps {\n  withHandle?: boolean;\n}\n\nconst SortableDragHandle = React.forwardRef<\n  HTMLButtonElement,\n  SortableDragHandleProps & React.ComponentPropsWithRef<typeof Button>\n>(({ className, ...props }, ref) => {\n  const { attributes, listeners, isDragging } = useSortableItem();\n\n  return (\n    <Button\n      ref={composeRefs(ref)}\n      data-state={isDragging ? \"dragging\" : undefined}\n      className={cn(\n        \"cursor-grab data-[state=dragging]:cursor-grabbing\",\n        className,\n      )}\n      {...attributes}\n      {...listeners}\n      {...props}\n    />\n  );\n});\nSortableDragHandle.displayName = \"SortableDragHandle\";\n\nexport { Sortable, SortableDragHandle, SortableItem, SortableOverlay };\n",
      "type": "registry:component"
    }
  ],
  "categories": [
    "other"
  ]
}