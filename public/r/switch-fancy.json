{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "switch-fancy",
  "type": "registry:component",
  "title": "Switch Fancy",
  "description": "A switch component with a fancy design",
  "registryDependencies": [
    "utils"
  ],
  "files": [
    {
      "path": "registry/default/components/switch-fancy.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nexport type OptionValue = string | number | boolean;\n\nexport interface OptionObject {\n  [key: string]: OptionValue | undefined;\n}\n\nexport type OptionType = OptionValue | OptionObject;\n\nexport interface SwitchFancyProps<T extends OptionType>\n  extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: T extends OptionObject ? T[keyof T] : T;\n  onChange?: (value: T extends OptionObject ? T[keyof T] : T) => void;\n  options: T[];\n  valueKey?: keyof T & string;\n  labelKey?: keyof T & string;\n  disabledKey?: keyof T & string;\n  className?: string;\n  radioClassName?: string;\n  highlighterClassName?: string;\n  highlighterIncludeMargin?: boolean;\n  highlighterStyle?: React.CSSProperties;\n  disabledOptions?: Array<T extends OptionObject ? T[keyof T] : T>;\n  renderOption?: (props: {\n    option: T extends OptionObject\n      ? T & { label: string; value: OptionValue; disabled: boolean }\n      : { label: string; value: T; disabled: boolean };\n    isSelected: boolean;\n    getOptionProps: () => Record<string, unknown>;\n  }) => React.ReactNode;\n}\n\nexport function SwitchFancy<T extends OptionType>({\n  options,\n  valueKey = \"value\" as keyof T & string,\n  labelKey = \"label\" as keyof T & string,\n  disabledKey = \"disabled\" as keyof T & string,\n  value,\n  onChange,\n  className,\n  radioClassName,\n  highlighterClassName,\n  highlighterIncludeMargin = false,\n  highlighterStyle: customHighlighterStyle,\n  disabledOptions = [],\n  renderOption,\n  ...props\n}: SwitchFancyProps<T>) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const radioRefs = useRef<(HTMLDivElement | null)[]>([]);\n\n  const getOptionValue = useCallback(\n    (option: T): OptionValue => {\n      if (typeof option !== \"object\") {\n        return option;\n      }\n      return option[valueKey] as OptionValue;\n    },\n    [valueKey],\n  );\n\n  const getOptionLabel = useCallback(\n    (option: T): string => {\n      if (typeof option !== \"object\") {\n        return String(option);\n      }\n      return String(option[labelKey]);\n    },\n    [labelKey],\n  );\n\n  const isOptionDisabled = useCallback(\n    (option: T): boolean => {\n      const optionValue = getOptionValue(option);\n      if (\n        disabledOptions.includes(\n          optionValue as T extends OptionObject ? T[keyof T] : T,\n        )\n      ) {\n        return true;\n      }\n      if (typeof option === \"object\" && disabledKey in option) {\n        return Boolean(option[disabledKey]);\n      }\n      return false;\n    },\n    [disabledOptions, getOptionValue, disabledKey],\n  );\n\n  const memoizedOptions = useMemo(\n    () =>\n      options.map((option) => ({\n        ...(typeof option === \"object\" ? option : {}),\n        label: getOptionLabel(option),\n        value: getOptionValue(option),\n        disabled: isOptionDisabled(option),\n      })) as Array<\n        T extends OptionObject\n          ? T & { label: string; value: OptionValue; disabled: boolean }\n          : { label: string; value: T; disabled: boolean }\n      >,\n    [options, getOptionValue, getOptionLabel, isOptionDisabled],\n  );\n\n  const [activeIndex, setActiveIndex] = useState(() => {\n    if (value === undefined) return 0;\n\n    const index = memoizedOptions.findIndex((option) => option.value === value);\n    if (index === -1) {\n      console.warn(\n        `SwitchFancy: No option found for value \"${value}\". Defaulting to first option.`,\n      );\n      return 0;\n    }\n    return index;\n  });\n\n  const [highlighterStyle, setHighlighterStyle] = useState({\n    height: 0,\n    width: 0,\n    transform: \"translate(0, 0)\",\n  });\n\n  const updateToggle = useCallback(() => {\n    const selectedElement = radioRefs.current[activeIndex];\n    const container = containerRef.current;\n\n    if (selectedElement && container) {\n      const containerRect = container.getBoundingClientRect();\n      const selectedRect = selectedElement.getBoundingClientRect();\n\n      const containerStyle = window.getComputedStyle(container);\n      const selectedStyle = window.getComputedStyle(selectedElement);\n\n      const containerPadding = {\n        left: parseFloat(containerStyle.paddingLeft),\n        top: parseFloat(containerStyle.paddingTop),\n      };\n      const containerBorder = {\n        left: parseFloat(containerStyle.borderLeftWidth),\n        top: parseFloat(containerStyle.borderTopWidth),\n      };\n      const selectedMargin = {\n        left: parseFloat(selectedStyle.marginLeft),\n        right: parseFloat(selectedStyle.marginRight),\n        top: parseFloat(selectedStyle.marginTop),\n        bottom: parseFloat(selectedStyle.marginBottom),\n      };\n\n      const translateX =\n        selectedRect.left -\n        containerRect.left -\n        containerPadding.left -\n        containerBorder.left -\n        (highlighterIncludeMargin ? selectedMargin.left : 0);\n\n      const translateY =\n        selectedRect.top -\n        containerRect.top -\n        containerPadding.top -\n        containerBorder.top -\n        selectedMargin.top;\n\n      setHighlighterStyle({\n        height: selectedRect.height,\n        width:\n          selectedRect.width +\n          (highlighterIncludeMargin\n            ? selectedMargin.left + selectedMargin.right\n            : 0),\n        transform: `translate(${translateX}px, ${translateY}px)`,\n      });\n    }\n  }, [activeIndex, highlighterIncludeMargin]);\n\n  const handleChange = useCallback(\n    (index: number) => {\n      if (!memoizedOptions[index].disabled) {\n        radioRefs.current[index]?.focus();\n        setActiveIndex(index);\n        onChange?.(\n          memoizedOptions[index].value as T extends OptionObject\n            ? T[keyof T]\n            : T,\n        );\n      }\n    },\n    [memoizedOptions, onChange],\n  );\n\n  const renderOptionContent = useCallback(\n    (option: (typeof memoizedOptions)[0], index: number) => {\n      const isSelected = index === activeIndex;\n\n      if (renderOption) {\n        return renderOption({\n          option,\n          isSelected,\n          getOptionProps: () => ({\n            ref: (el: HTMLDivElement | null) => (radioRefs.current[index] = el),\n            role: \"radio\",\n            \"aria-checked\": isSelected,\n            tabIndex: isSelected && !option.disabled ? 0 : -1,\n            onClick: () => handleChange(index),\n            className: radioClassName,\n            ...(isSelected ? { \"data-checked\": true } : {}),\n            ...(option.disabled\n              ? { \"aria-disabled\": true, \"data-disabled\": true }\n              : {}),\n            \"aria-label\": `${option.label} option`,\n          }),\n        });\n      }\n\n      return (\n        <div\n          ref={(el) => {\n            radioRefs.current[index] = el;\n          }}\n          role=\"radio\"\n          aria-checked={isSelected}\n          tabIndex={isSelected && !option.disabled ? 0 : -1}\n          onClick={() => handleChange(index)}\n          className={cn(\n            \"relative flex h-9 cursor-pointer items-center justify-center\",\n            \"data-[checked]:text-primary-foreground rounded-full px-3.5 text-sm font-medium transition-colors\",\n            \"data-[disabled]:cursor-not-allowed data-[disabled]:opacity-50\",\n            radioClassName,\n          )}\n          {...(isSelected ? { \"data-checked\": true } : {})}\n          {...(option.disabled\n            ? { \"aria-disabled\": true, \"data-disabled\": true }\n            : {})}\n          aria-label={`${option.label} option`}\n        >\n          {option.label}\n        </div>\n      );\n    },\n    [activeIndex, renderOption, radioClassName, handleChange],\n  );\n\n  useEffect(() => {\n    updateToggle();\n  }, [updateToggle]);\n\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(updateToggle);\n    if (containerRef.current) {\n      resizeObserver.observe(containerRef.current);\n    }\n    return () => resizeObserver.disconnect();\n  }, [updateToggle]);\n\n  useEffect(() => {\n    const newIndex = memoizedOptions.findIndex(\n      (option) => option.value === value,\n    );\n    if (newIndex !== -1 && newIndex !== activeIndex) {\n      setActiveIndex(newIndex);\n    }\n  }, [value, memoizedOptions, activeIndex]);\n\n  return (\n    <div\n      role=\"radiogroup\"\n      aria-label=\"Switch options\"\n      ref={containerRef}\n      className={cn(\"bg-muted rounded-xl p-2\", className)}\n      onKeyDown={(e) => {\n        props.onKeyDown?.(e);\n\n        if (!e.defaultPrevented) {\n          switch (e.key) {\n            case \"ArrowDown\":\n            case \"ArrowRight\":\n              e.preventDefault();\n              const nextIndex = (activeIndex + 1) % options.length;\n              handleChange(nextIndex);\n              break;\n            case \"ArrowUp\":\n            case \"ArrowLeft\":\n              e.preventDefault();\n              const prevIndex =\n                (activeIndex - 1 + options.length) % options.length;\n              handleChange(prevIndex);\n              break;\n            default:\n              break;\n          }\n        }\n      }}\n      {...props}\n    >\n      <div\n        className={cn(\n          \"absolute transition-all duration-300 ease-[cubic-bezier(0.4,0,0.2,1)]\",\n          \"bg-primary rounded-full\",\n          highlighterClassName,\n        )}\n        style={{\n          ...highlighterStyle,\n          ...customHighlighterStyle,\n        }}\n        aria-hidden=\"true\"\n        data-highlighter\n      />\n\n      {memoizedOptions.map((option, index) => (\n        <React.Fragment key={option.value.toString()}>\n          {renderOptionContent(option, index)}\n        </React.Fragment>\n      ))}\n\n      <div\n        aria-live=\"polite\"\n        className=\"clip-rect-0 absolute -m-px h-px w-px overflow-hidden border-0 p-0 whitespace-nowrap\"\n      >\n        {memoizedOptions[activeIndex]?.label} selected\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ],
  "categories": [
    "input"
  ]
}