{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "wheel-picker",
  "type": "registry:component",
  "title": "Wheel Picker",
  "description": "A wheel picker component",
  "registryDependencies": [
    "utils"
  ],
  "files": [
    {
      "path": "registry/default/components/wheel-picker.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { useControllableState } from \"@/registry/default/hooks/use-controllable-state\";\nimport { cn } from \"@/lib/utils\";\n\ntype WheelPickerOption = {\n  value: string;\n  label: string;\n};\n\ntype WheelPickerClassNames = {\n  optionItem?: string;\n  highlightWrapper?: string;\n  highlightItem?: string;\n};\n\ntype WheelPickerProps = {\n  defaultValue?: string;\n  value?: string;\n  onValueChange?: (value: string) => void;\n  options: WheelPickerOption[];\n  infinite?: boolean;\n  visibleCount?: number;\n  dragSensitivity?: number;\n  classNames?: WheelPickerClassNames;\n};\n\ntype WheelPickerWrapperProps = {\n  className?: string;\n  children: React.ReactNode;\n};\n\nconst RESISTANCE = 0.3; // Resistance when scrolling above the top or below the bottom\nconst MAX_VELOCITY = 30; // Maximum velocity for the scroll animation\n\nconst easeOutCubic = (p: number) => Math.pow(p - 1, 3) + 1;\n\n// Clamp utility to constrain a value within bounds\nconst clamp = (value: number, min: number, max: number) =>\n  Math.max(min, Math.min(value, max));\n\nconst WheelPickerWrapper: React.FC<WheelPickerWrapperProps> = ({\n  className,\n  children,\n}) => {\n  return (\n    <div\n      className={cn(\n        \"relative flex w-full items-stretch justify-between overflow-hidden select-none\",\n        \"[perspective:2000px]\",\n        className,\n      )}\n      data-rwp-wrapper\n    >\n      {children}\n    </div>\n  );\n};\n\nconst WheelPicker: React.FC<WheelPickerProps> = ({\n  defaultValue,\n  value: valueProp,\n  onValueChange,\n\n  options: optionsProp,\n  infinite: infiniteProp = false,\n  visibleCount: countProp = 20,\n  dragSensitivity: dragSensitivityProp = 3,\n  classNames,\n}) => {\n  const [value = optionsProp[0]?.value ?? \"\", setValue] = useControllableState({\n    defaultProp: defaultValue,\n    prop: valueProp,\n    onChange: onValueChange,\n  });\n\n  const options = useMemo<WheelPickerOption[]>(() => {\n    if (!infiniteProp) {\n      return optionsProp;\n    }\n\n    const result: WheelPickerOption[] = [];\n    const halfCount = Math.ceil(countProp / 2);\n\n    if (optionsProp.length === 0) {\n      return result;\n    }\n\n    while (result.length < halfCount) {\n      result.push(...optionsProp);\n    }\n\n    return result;\n  }, [countProp, optionsProp, infiniteProp]);\n\n  const itemHeight = 30;\n  const halfItemHeight = itemHeight * 0.5;\n  const itemAngle = 360 / countProp;\n  const radius = itemHeight / Math.tan((itemAngle * Math.PI) / 180);\n  const containerHeight = Math.round(radius * 2 + itemHeight * 0.25);\n  const quarterCount = countProp >> 2; // Divide by 4\n  const baseDeceleration = dragSensitivityProp * 10;\n  const snapBackDeceleration = 10;\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const wheelItemsRef = useRef<HTMLUListElement>(null);\n  const highlightListRef = useRef<HTMLUListElement>(null);\n\n  const scrollRef = useRef(0);\n  const moveId = useRef(0);\n  const dragingRef = useRef(false);\n  const lastWheelRef = useRef(0);\n\n  const touchDataRef = useRef<{\n    startY: number;\n    yList: [number, number][];\n    touchScroll?: number;\n  }>({\n    startY: 0,\n    yList: [],\n  });\n\n  const dragControllerRef = useRef<AbortController | null>(null);\n\n  const renderWheelItems = useMemo(() => {\n    const renderItem = (\n      item: WheelPickerOption,\n      index: number,\n      angle: number,\n    ) => (\n      <li\n        key={index}\n        className={cn(\n          \"absolute top-0 left-0 w-full text-sm\",\n          \"[-webkit-font-smoothing:subpixel-antialiased] [will-change:visibility]\",\n          classNames?.optionItem,\n        )}\n        data-rwp-option\n        data-index={index}\n        style={{\n          top: -halfItemHeight,\n          height: itemHeight,\n          lineHeight: `${itemHeight}px`,\n          transform: `rotateX(${angle}deg) translateZ(${radius}px)`,\n          visibility: \"hidden\",\n        }}\n      >\n        {item.label}\n      </li>\n    );\n\n    const items = options.map((option, index) =>\n      renderItem(option, index, -itemAngle * index),\n    );\n\n    if (infiniteProp) {\n      for (let i = 0; i < quarterCount; ++i) {\n        const prependIndex = -i - 1;\n        const appendIndex = i + options.length;\n\n        items.unshift(\n          renderItem(\n            options[options.length - i - 1],\n            prependIndex,\n            itemAngle * (i + 1),\n          ),\n        );\n        items.push(\n          renderItem(options[i], appendIndex, -itemAngle * appendIndex),\n        );\n      }\n    }\n\n    return items;\n  }, [\n    halfItemHeight,\n    infiniteProp,\n    itemAngle,\n    options,\n    quarterCount,\n    radius,\n    classNames?.optionItem,\n  ]);\n\n  const renderHighlightItems = useMemo(() => {\n    const renderItem = (item: WheelPickerOption, key: React.Key) => (\n      <li\n        key={key}\n        data-slot=\"highlight-item\"\n        className={classNames?.highlightItem}\n        style={{ height: itemHeight }}\n      >\n        {item.label}\n      </li>\n    );\n\n    const items = options.map((option, index) => renderItem(option, index));\n\n    if (infiniteProp) {\n      const firstItem = options[0];\n      const lastItem = options[options.length - 1];\n\n      items.unshift(renderItem(lastItem, \"infinite-start\"));\n      items.push(renderItem(firstItem, \"infinite-end\"));\n    }\n\n    return items;\n  }, [classNames?.highlightItem, infiniteProp, options]);\n\n  const normalizeScroll = (scroll: number) =>\n    ((scroll % options.length) + options.length) % options.length;\n\n  const scrollTo = (scroll: number) => {\n    const normalizedScroll = infiniteProp ? normalizeScroll(scroll) : scroll;\n\n    if (wheelItemsRef.current) {\n      const transform = `translateZ(${-radius}px) rotateX(${itemAngle * normalizedScroll}deg)`;\n      wheelItemsRef.current.style.transform = transform;\n\n      wheelItemsRef.current.childNodes.forEach((node) => {\n        const li = node as HTMLLIElement;\n        const distance = Math.abs(Number(li.dataset.index) - normalizedScroll);\n        li.style.visibility = distance > quarterCount ? \"hidden\" : \"visible\";\n      });\n    }\n\n    if (highlightListRef.current) {\n      highlightListRef.current.style.transform = `translateY(${-normalizedScroll * itemHeight}px)`;\n    }\n\n    return normalizedScroll;\n  };\n\n  const cancelAnimation = () => {\n    cancelAnimationFrame(moveId.current);\n  };\n\n  const animateScroll = (\n    startScroll: number,\n    endScroll: number,\n    duration: number,\n    onComplete?: () => void,\n  ) => {\n    if (startScroll === endScroll || duration === 0) {\n      scrollTo(startScroll);\n      return;\n    }\n\n    const startTime = performance.now();\n    const totalDistance = endScroll - startScroll;\n\n    const tick = (currentTime: number) => {\n      const elapsed = (currentTime - startTime) / 1000;\n\n      if (elapsed < duration) {\n        const progress = easeOutCubic(elapsed / duration);\n        scrollRef.current = scrollTo(startScroll + progress * totalDistance);\n        moveId.current = requestAnimationFrame(tick);\n      } else {\n        cancelAnimation();\n        scrollRef.current = scrollTo(endScroll);\n        onComplete?.();\n      }\n    };\n\n    requestAnimationFrame(tick);\n  };\n\n  const selectByScroll = (scroll: number) => {\n    const normalized = normalizeScroll(scroll) | 0;\n\n    const boundedScroll = infiniteProp\n      ? normalized\n      : Math.min(Math.max(normalized, 0), options.length - 1);\n\n    if (!infiniteProp && boundedScroll !== scroll) return;\n\n    scrollRef.current = scrollTo(boundedScroll);\n    const selected = options[scrollRef.current];\n    setValue(selected.value);\n  };\n\n  const selectByValue = (value: string) => {\n    const index = options.findIndex((opt) => opt.value === value);\n\n    if (index === -1) {\n      console.error(\"Invalid value selected:\", value);\n      return;\n    }\n\n    cancelAnimation();\n    selectByScroll(index);\n  };\n\n  const updateScrollDuringDrag = (e: MouseEvent | TouchEvent) => {\n    try {\n      const currentY =\n        (e instanceof MouseEvent ? e.clientY : e.touches?.[0]?.clientY) || 0;\n\n      const touchData = touchDataRef.current;\n\n      // Record current Y position with timestamp\n      touchData.yList.push([currentY, Date.now()]);\n      if (touchData.yList.length > 5) {\n        touchData.yList.shift(); // Keep latest 5 points for velocity calc\n      }\n\n      // Calculate delta in scroll position based on drag distance\n      const dragDelta = (touchData.startY - currentY) / itemHeight;\n      let nextScroll = scrollRef.current + dragDelta;\n\n      if (infiniteProp) {\n        // Wrap scroll for infinite lists\n        nextScroll = normalizeScroll(nextScroll);\n      } else {\n        const maxIndex = options.length;\n        if (nextScroll < 0) {\n          // Apply resistance when dragging above top\n          nextScroll *= RESISTANCE;\n        } else if (nextScroll > maxIndex) {\n          // Apply resistance when dragging below bottom\n          nextScroll = maxIndex + (nextScroll - maxIndex) * RESISTANCE;\n        }\n      }\n\n      // Update visual scroll and store position\n      touchData.touchScroll = scrollTo(nextScroll);\n    } catch (error) {\n      console.error(\"Error in updateScrollDuringDrag:\", error);\n    }\n  };\n\n  const handleDragMoveEvent = (event: MouseEvent | TouchEvent) => {\n    if (\n      !dragingRef.current &&\n      !containerRef.current!.contains(event.target as Node) &&\n      event.target !== containerRef.current\n    ) {\n      return;\n    }\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    if (options.length) {\n      updateScrollDuringDrag(event);\n    }\n  };\n\n  const initiateDragGesture = (event: MouseEvent | TouchEvent) => {\n    try {\n      dragingRef.current = true;\n\n      const controller = new AbortController();\n      const { signal } = controller;\n\n      dragControllerRef.current = controller;\n\n      // Listen to movement events\n      const passiveOpts = { signal, passive: false };\n      containerRef.current?.addEventListener(\n        \"touchmove\",\n        handleDragMoveEvent,\n        passiveOpts,\n      );\n      document.addEventListener(\"mousemove\", handleDragMoveEvent, passiveOpts);\n\n      const startY =\n        (event instanceof MouseEvent\n          ? event.clientY\n          : event.touches?.[0]?.clientY) || 0;\n\n      // Initialize touch tracking\n      const touchData = touchDataRef.current;\n      touchData.startY = startY;\n      touchData.yList = [[startY, Date.now()]];\n      touchData.touchScroll = scrollRef.current;\n\n      // Stop any ongoing scroll animation\n      cancelAnimation();\n    } catch (error) {\n      console.error(\"Error in initiateDragGesture:\", error);\n    }\n  };\n\n  const handleDragStartEvent = useCallback(\n    (e: MouseEvent | TouchEvent) => {\n      const isDragging = dragingRef.current;\n      const isTargetValid =\n        containerRef.current!.contains(e.target as Node) ||\n        e.target === containerRef.current;\n\n      if ((isDragging || isTargetValid) && e.cancelable) {\n        e.preventDefault();\n        if (options.length) {\n          initiateDragGesture(e);\n        }\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [initiateDragGesture],\n  );\n\n  const decelerateAndAnimateScroll = (initialVelocity: number) => {\n    const currentScroll = scrollRef.current;\n    let targetScroll = currentScroll;\n    let deceleration =\n      initialVelocity > 0 ? -baseDeceleration : baseDeceleration;\n    let duration = 0;\n\n    if (infiniteProp) {\n      // Infinite mode: apply uniform deceleration to calculate scroll distance\n      duration = Math.abs(initialVelocity / deceleration);\n      const scrollDistance =\n        initialVelocity * duration + 0.5 * deceleration * duration * duration;\n      targetScroll = Math.round(currentScroll + scrollDistance);\n    } else if (currentScroll < 0 || currentScroll > options.length - 1) {\n      // Out-of-bounds: snap back to nearest valid scroll index\n      const target = clamp(currentScroll, 0, options.length - 1);\n      const scrollDistance = currentScroll - target;\n      deceleration = snapBackDeceleration;\n      duration = Math.sqrt(Math.abs(scrollDistance / deceleration));\n      initialVelocity = deceleration * duration;\n      initialVelocity = currentScroll > 0 ? -initialVelocity : initialVelocity;\n      targetScroll = target;\n    } else {\n      // Normal decelerated scroll within bounds\n      duration = Math.abs(initialVelocity / deceleration);\n      const scrollDistance =\n        initialVelocity * duration + 0.5 * deceleration * duration * duration;\n      targetScroll = Math.round(currentScroll + scrollDistance);\n      targetScroll = clamp(targetScroll, 0, options.length - 1);\n\n      const adjustedDistance = targetScroll - currentScroll;\n      duration = Math.sqrt(Math.abs(adjustedDistance / deceleration));\n    }\n\n    // Start animation to target scroll position with calculated duration\n    animateScroll(currentScroll, targetScroll, duration, () => {\n      selectByScroll(scrollRef.current); // Ensure selected item updates at end\n    });\n\n    // Fallback selection update (in case animation callback fails)\n    selectByScroll(scrollRef.current);\n  };\n\n  const finalizeDragAndStartInertiaScroll = () => {\n    try {\n      dragControllerRef.current?.abort();\n      dragControllerRef.current = null;\n\n      const touchData = touchDataRef.current;\n      const yList = touchData.yList;\n      let velocity = 0;\n\n      if (yList.length > 1) {\n        const len = yList.length;\n        const [startY, startTime] = yList[len - 2] ?? [0, 0];\n        const [endY, endTime] = yList[len - 1] ?? [0, 0];\n\n        const timeDiff = endTime - startTime;\n\n        if (timeDiff > 0) {\n          const distance = startY - endY;\n          const velocityPerSecond = ((distance / itemHeight) * 1000) / timeDiff;\n\n          const maxVelocity = MAX_VELOCITY;\n          const direction = velocityPerSecond > 0 ? 1 : -1;\n          const absVelocity = Math.min(\n            Math.abs(velocityPerSecond),\n            maxVelocity,\n          );\n          velocity = absVelocity * direction;\n        }\n      }\n\n      scrollRef.current = touchData.touchScroll ?? scrollRef.current;\n      decelerateAndAnimateScroll(velocity);\n    } catch (error) {\n      console.error(\"Error in finalizeDragAndStartInertiaScroll:\", error);\n    } finally {\n      dragingRef.current = false;\n    }\n  };\n\n  const handleDragEndEvent = useCallback(\n    (event: MouseEvent | TouchEvent) => {\n      if (!options.length) return;\n\n      const isDragging = dragingRef.current;\n      const isTargetValid =\n        containerRef.current!.contains(event.target as Node) ||\n        event.target === containerRef.current;\n\n      if ((isDragging || isTargetValid) && event.cancelable) {\n        event.preventDefault();\n        finalizeDragAndStartInertiaScroll();\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [finalizeDragAndStartInertiaScroll],\n  );\n\n  const scrollByWheel = (event: WheelEvent) => {\n    event.preventDefault();\n\n    const now = Date.now();\n    if (now - lastWheelRef.current < 100) return;\n\n    const direction = Math.sign(event.deltaY);\n    if (!direction) return;\n\n    lastWheelRef.current = now;\n\n    const startScroll = scrollRef.current;\n    let endScroll = startScroll + direction;\n\n    if (infiniteProp) {\n      endScroll = Math.round(endScroll);\n    } else {\n      endScroll = clamp(Math.round(endScroll), 0, options.length - 1);\n    }\n\n    const distance = Math.abs(endScroll - startScroll);\n    if (distance === 0) return;\n\n    const duration = Math.sqrt(distance / 5);\n\n    cancelAnimation();\n    animateScroll(startScroll, endScroll, duration, () => {\n      selectByScroll(scrollRef.current);\n    });\n  };\n\n  const handleWheelEvent = useCallback(\n    (event: WheelEvent) => {\n      if (!options.length || !containerRef.current) return;\n\n      const isDragging = dragingRef.current;\n      const isTargetValid =\n        containerRef.current.contains(event.target as Node) ||\n        event.target === containerRef.current;\n\n      if ((isDragging || isTargetValid) && event.cancelable) {\n        event.preventDefault();\n        scrollByWheel(event);\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [scrollByWheel],\n  );\n\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    const controller = new AbortController();\n    const { signal } = controller;\n\n    const opts = { signal, passive: false };\n\n    container.addEventListener(\"touchstart\", handleDragStartEvent, opts);\n    container.addEventListener(\"touchend\", handleDragEndEvent, opts);\n    container.addEventListener(\"wheel\", handleWheelEvent, opts);\n    document.addEventListener(\"mousedown\", handleDragStartEvent, opts);\n    document.addEventListener(\"mouseup\", handleDragEndEvent, opts);\n\n    return () => controller.abort();\n  }, [handleDragEndEvent, handleDragStartEvent, handleWheelEvent]);\n\n  useEffect(() => {\n    selectByValue(value);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [value, valueProp]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\n        \"relative flex-1 cursor-ns-resize overflow-hidden text-center\",\n        \"[mask-image:linear-gradient(to_bottom,transparent_0%,black_20%,black_80%,transparent_100%)]\",\n      )}\n      data-rwp\n      style={{ height: containerHeight }}\n    >\n      <ul\n        ref={wheelItemsRef}\n        className={cn(\n          \"absolute top-1/2 left-0 mx-auto block h-0 w-full\",\n          \"[-webkit-font-smoothing:subpixel-antialiased] [will-change:transform]\",\n          \"list-none [backface-visibility:hidden] [transform-style:preserve-3d]\",\n        )}\n        data-rwp-options\n      >\n        {renderWheelItems}\n      </ul>\n\n      <div\n        className={cn(\n          \"absolute top-1/2 w-full overflow-hidden text-base font-medium\",\n          \"-translate-y-1/2\",\n          classNames?.highlightWrapper,\n        )}\n        data-rwp-highlight-wrapper\n        style={{\n          height: itemHeight,\n          lineHeight: itemHeight + \"px\",\n        }}\n      >\n        <ul\n          ref={highlightListRef}\n          className=\"absolute w-full list-none\"\n          data-rwp-highlight-list\n          style={{\n            top: infiniteProp ? -itemHeight : undefined,\n          }}\n        >\n          {renderHighlightItems}\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport {\n  WheelPicker,\n  type WheelPickerOption,\n  WheelPickerWrapper,\n  type WheelPickerClassNames,\n  type WheelPickerProps,\n  type WheelPickerWrapperProps,\n};\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/hooks/use-controllable-state.ts",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n\n// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\n\nimport React from \"react\";\n\ntype UseControllableStateParams<T> = {\n  prop?: T | undefined;\n  defaultProp?: T | undefined;\n  onChange?: (state: T) => void;\n};\n\ntype SetStateFn<T> = (prevState?: T) => T;\n\nfunction useCallbackRef<T extends (...args: any[]) => any>(\n  callback: T | undefined,\n): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(\n    () => ((...args) => callbackRef.current?.(...args)) as T,\n    [],\n  );\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, \"prop\">) {\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value as T);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n\n  return uncontrolledState;\n}\n\nexport function useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n}: UseControllableStateParams<T>) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\n    defaultProp,\n    onChange,\n  });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> =\n    React.useCallback(\n      (nextValue) => {\n        if (isControlled) {\n          const setter = nextValue as SetStateFn<T>;\n          const value =\n            typeof nextValue === \"function\" ? setter(prop) : nextValue;\n          if (value !== prop) handleChange(value as T);\n        } else {\n          setUncontrolledProp(nextValue);\n        }\n      },\n      [isControlled, prop, setUncontrolledProp, handleChange],\n    );\n\n  return [value, setValue] as const;\n}\n",
      "type": "registry:hook"
    }
  ],
  "categories": [
    "input"
  ]
}